/*
  @ Javascript Engine - Final
      $ How can a machine actually understand the code we've written?

      ? As Javascript devs, we usually don't have to deal with compilers ourselves!

      ^ But it's good to know the basics of the Javascript engine
        # How it handles our human-friendly JS code, and turns it into something machine understand!


        > HTML Parser
            & It encounters a "script" tag with a source

            = From script, the source gets loaded from either
              ^ Network (or)
              ^ Cache (or)
              ^ An installed Service Worker

            = Response is the requested script as
              ^ A Stream of bytes
                  @ Byte Stream Decoder takes care the stream of bytes


        ! The script gets loaded as a UTF-16 byte stream from either network, cahce, or a worker, and passed to a byte stream decoder


  $ Network | Cache | Worker --- (Byte Stream) ---> Byte Steam Decoder

    @ Byte Stream Decoder
      * Creates "tokens" from the decoded system of bytes
          > Token Creation
            ^ 0066 decodes to f,
            ^ 0075 to u,
            ^ 006e to n,
            ^ 0063 to c,
            ^ 0074 to t,
            ^ 0069 to i,
            ^ 006f to o,
            ^ and 006e to n
              = followed by a white space
                # function - a reserved keyword in Javascript

        > Token to Parser (pre-parser)
            ^ Same happens for the rest of the byte stream

        ! The byte stream decoder decodes the bytes into "tokens", and the tokens are sent to the "parser"!

        $ Two Parsers
            * Pre-Parser
            * Parser

            ? In order to reduce the time it takes to load up a website, engine tries to avoid parsing unnessary codes right away

            # Pre-Parser
              ^ Handles code that may be used later on!
                ? Certain function will only get invoked after a user clicks a button, it isn't necessary that this code is compiled immediately just to load up a website...

                $ If the user eventually ends up clicking the button and requiring that piece of code, it gets sent to the parser!

            # Parser
              ^ Handles the code that's needed immediately!

        ! Parser Creates nodes based on the tokens it receives from the byte stream coder
            $ With these nodes, it creates an Abstract Syntax Tree or AST!

      * Parser --> Nodes (based on tokens) --> Abstract Syntax Tree


    # PARSER

      - KEYWORD                IDENTIFIER
      ^ function                greeting

      - PUNCTUATOR              PUNCTUATOR
      ^    {                      }

      - PUNCTUATOR              KEYWOROD
      ^  {                      return

      - STRING                  PUNCTUATOR
      ^  "hi"                      }

      # ABSTRACT SYNTAX TREE
          = Program
            = FunctionLiteral
              = ReturnStatement
                = StringLiteral


  @ Interpreter
      $ Which walks through the AST (Abstract Syntax Tree)
          ? Generates "byte code" based on the information that the AST contains...

          ^ Once the byte code has been generated fully, the AST is deleted, clearing up memory space

            & Byte Code - Finally, a machine can work with!

      ! The interpreter walks through the AST and generates byte code

      # Byte code is fast, it can be faster!

      $ We've been invoking a function dozens of times; it's time to optimize this so it'll run even faster!

        > Byte code with generated type feedback sent to an
          ^ Optimizing Compiler

  @ Optimizing Compiler
        * Takes the byte code and type feedback, and generates highly optimized machine code


        ! The "byte code" and "type feedback" are sent to the "optimizing compiler", which generates highly optimized "machine code"!

  # Javascript is a dynamically typed language, meaning that types of data can change constantly

      & It would be extremely slow if the JS engine had to check each time which data type a certain value has!

        ? In order to reduce the time it takes to interpret the code, optimized machine code only handles the cases the engine has seen before while running the bytecode

        ^ If we repeatedly used a certain piece of code that returned the same data type over and over, the optimized machine code can simply be re-used in order to speed things up

        * JavaScript is dynamically typed, it can happen that the same piece of code suddenly returns a different type of data
          $ The machine code gets de-optimized, and the engine falls back to interpreting the generated byte code

          ! Say a certain function is invoked a 100 times and has always returned the same value so far

            = It will assume that it will also return this value the 101st time we invoke it

              function sum(x, y) {
                return x + y;
              }

              sum(1, 2); // 3

              # The next time we invoke it, it will assume that we’re invoking it again with two numerical values...

              $ If that’s true, no dynamic lookup is required

              * It can just re-use the optimized machine code

              ? Else, if the assumption was incorrect, it will revert back to the original byte code instead of the optimized machine code

                ^ The next time we invoke it, we pass a string instead of a number
                  - JavaScript is dynamically typed, we can do this without any errors!

                    function sum(x, y) {
                      return x + y;
                    }

                    sum("1", 2); // "12"

                ! The number 2 will get coerced into a string and function return "12"
                    * It goes back to executing the interpreted bytecode and updates the type feedback










*/
